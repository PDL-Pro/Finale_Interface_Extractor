 ; basic/void method ; value-returning method 
 ABAP Objects ; methods name «importing parameter = argument» «exporting parameter = argument» «changing parameter = argument» «returning value(parameter)»method name. instructions endmethod.The declaration and implementation of methods in ABAP are separate. methods statement is to be used inside the class definition. method (without "s") is to be used inside the class implementation. parameter = argument can be repeated if there are several parameters. ;In ABAP, the return parameter name is explicitly defined in the method signature within the class definition 
 APL (Dyalog) ; ∇ «left argument» name «right arguments»instructions∇ ; ∇ result ← «left argument» name «right arguments»instructions∇ 
 C++In C++, declaring and implementing methods is usually separate. Methods are declared in the class definition (which is usually included in a header file) using the syntax  The implementation of methods is usually provided in a separate source file, with the following syntax  Although the body of a method can be included with the declaration inside the class definition, as shown in the table here, this is generally bad practice. Because the class definition must be included with every source file which uses the fields or methods of the class, having code in the class definition causes the method code to be compiled with every source file, increasing the size of the code. Yet, in some circumstances, it is useful to include the body of a method with the declaration. One reason is that the compiler will try to inline methods that are included in the class declaration, so if a very short one-line method occurs, it may make it faster to allow a compiler to inline it, by including the body along with the declaration. Also, if a template class or method occurs, then all the code must be included with the declaration, because only with the code can the template be instantiated. ; void foo(«parameters») { instructions } ; type foo(«parameters») { instructions ... return value, } 
 C# ; void foo(«parameters») { instructions } ; type foo(«parameters») { instructions ... return value, } 
 D ; void foo(«parameters») { instructions } ; type foo(«parameters») { instructions ... return value, } 
 Java ; void foo(«parameters») { instructions } ; type foo(«parameters») { instructions ... return value, } 
 eC ; void ««type of 'this'»::»foo(«parameters») { instructions } ; type ««type of this»::»foo(«parameters») { instructions ... return value, } 
 Eiffel ; foo ( «parameters» ) do  instructions  end ; foo ( «parameters» ): TYPE  do  instructions...  Result := value  end 
 Objective-C ; - (void)foo«:parameter «bar:parameter ...»» { instructions } ; - (type)foo«:parameter «bar:parameter ...»» { instructions... return value, } 
 Swift ; func foo(«parameters») { instructions } ; func foo(«parameters») -> type { instructions... return value } 
 Python ; def foo(self«, parameters»): Tab instructions ; def foo(self«, parameters»): Tab instructions Tab return value 
 Visual Basic .NET ; Sub Foo(«parameters»)  instructions  End Sub ; Function Foo(«parameters») As type  instructions  ...  Return value End Function 
 Xojo ; Sub Foo(«parameters»)  instructions  End Sub ; Function Foo(«parameters») As type  instructions  ...  Return value End Function 
 PHP ; function foo(«parameters»)«: void» { instructions } ; function foo(«parameters»)«: type» { instructions ... return value, } 
 Perl ; sub foo { my ($self«, parameters») = @_, instructions } ; sub foo { my ($self«, parameters») = @_, instructions ... return value, } 
 Raku ; «has »«multi »method foo(««$self:  »parameters») { instructions } ; «has «type »»«multi »method foo(««$self:  »parameters») { instructions ... return value, } 
 Ruby ; def foo«(parameters)»  instructions  end ; def foo«(parameters)»  instructions  expression resulting in return value  end  or  def foo«(parameters)»  instructions  return value  end 
 Windows PowerShell ; Add-Member «-MemberType» ScriptMethod «-Name» foo «-Value» { «param(parameters)» instructions } -InputObject variable ; Add-Member «-MemberType» ScriptMethod «-Name» foo «-Value» { «param(parameters)» instructions ... return value } -InputObject variable 
 OCaml ; rowspan=2 n/a ; method foo «parameters» = expression 
 F# ; member this.foo(«parameters») = expression 
 JavaScript ; this.method = function(«parameters») {instructions}  name«.prototype.method = function(«parameters») {instructions}Just assign a function to it in a method ;  this.method = function(«parameters») {instructions... return value,}  name«.prototype.method = function(«parameters») {instructions... return value,} 
Javascript (ES6) ;foo(«parameters») {instructions} ;foo(«parameters») {instructions... return value,} 
 COBOL ; METHOD-ID. foo.«DATA DIVISION.LINKAGE SECTION.parameter declarations»PROCEDURE DIVISION« USING parameters». instructions END METHOD foo. ; METHOD-ID. foo.DATA DIVISION.LINKAGE SECTION.«parameter declarations»result-var declarationPROCEDURE DIVISION« USING parameters» RETURNING result-var. instructions END METHOD foo. 
 Cobra ; def foo(parameters)Tab instructions ; def foo(parameters) as typeTab instructionsTab return value ; 
 ISLISP ; (defgeneric method (arg1 arg2))(defmethod method ((arg1  arg2 ) ...) ; 
