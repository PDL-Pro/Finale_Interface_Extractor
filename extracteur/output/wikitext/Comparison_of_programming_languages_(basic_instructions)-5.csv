 ;Simple composite types ;Simple composite types ;Algebraic data type ;Unions 
 ; Records ; Tuple expression ;Algebraic data type ;Unions 
 Ada ; type identifier is «abstract» «tagged» «limited» [recordfieldname1 : type,fieldname2 : type,...end record |null record] ; n/a ; Any combination of records, unions and enumerations (as well as references to those, enabling recursive types). ; type identifier (variation : discrete_type) is recordcase variation iswhen choice_list1 =>fieldname1 : type,...when choice_list2 =>fieldname2 : type,......end case,end record 
 ALGOL 68 ; struct (modename «fieldname», ...), ; Required types and operators can be user defined ; Required types and operators can be user defined ; union (modename, ...), 
 C (C99) ; struct «name» {type name,...}, ; rowspan=2 n/a ; rowspan=3 n/a ; union {type name,...}, 
 Objective-C ; struct «name» {type name,...}, ; union {type name,...}, 
 C++ ; struct «name» {type name,...}, ; «std::»tuple<type1..typen> ; union {type name,...}, 
 C# ; struct name {type name,...} ;(val1, val2, ... ) ; ; rowspan=3 n/a 
 Java ; n/a ; ; 
 JavaScript ; ; n/a ; 
 D ; struct name {type name,...} ;  ; std.variant.Algebraic!(type,...) ; union {type name,...} 
 Go ; struct {«name» type...} ;  ;  ;  
 Rust ; struct name {name: type, ...} ; (val1, val2, ... ) ; enum name { Foo(types), ...} ; union name {name: type, ...} 
 Swift ; struct name {var name «: type»...} ; («name1:» val1, «name2:» val2, «name3:» val3, ... ) ; enum name { case Foo«(types)» case Bar «(types)» ... } ;  
 Common Lisp ; (defstruct name slot-name (slot-name initial-value) (slot-name initial-value :type type) ...) ; (cons val1 val2) ; ; 
 Scheme ; n/a ; (cons val1 val2) ; ; 
 ISLISP ; ; (cons val1 val2) ; ; 
 Pascal ; recordname: type,...end ; n/a ; n/a ; recordcase type of value: (types),...end 
 Visual Basic ; ; ; ; 
 Visual Basic .NET ; Structure name  Dim name As type  ...  End Structure ;(val1, val2, ... ) ; ; 
 Python ; n/a ; «(»val1, val2, val3, ... «)» ; ; n/a 
 S-Lang ; struct {name [=value], ...} ; ; ; 
 Fortran ;TYPE name   type ::  name  ...  END TYPE ; ; ; 
 PHP ; n/a ; ; ; 
 Perl ; n/a ; ; ; rowspan=3 n/a 
 Raku ; n/a ; ; 
 Ruby ; {{code|lang=ruby|1=OpenStruct.new({:name => value})}} ; ; 
 Scala ; case class name(«var» name: type, ...) ; (val1, val2, val3, ... ) ; abstract class namecase class Foo(«parameters») extends namecase class Bar(«parameters») extends name... or abstract class namecase object Foo extends namecase object Bar extends name... or combination of case classes and case objects ; 
 Windows PowerShell ; ; ; ; 
 OCaml ; type name = {«mutable» name : type,...} ; «(»val1, val2, val3, ... «)» ; type name = Foo «of type» | Bar «of type» | ... ; rowspan=4 n/a 
 F# ; type name = {«mutable» name : type,...} ; «(»val1, val2, val3, ... «)» ; type name = Foo «of type» | Bar «of type» | ... 
 Standard ML ; type name = {name : type,...} ; (val1, val2, val3, ... ) ; datatype name = Foo «of type» | Bar «of type» | ... 
 Haskell ; data Name = Constr {name :: type,...} ; (val1, val2, val3, ... ) ; data Name = Foo «types» | Bar «types» | ... 
 COBOL ; level-number name type clauses.level-number+n name type clauses.... ; n/a ; n/a ; name REDEFINES variable type. 
