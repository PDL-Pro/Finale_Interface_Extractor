 ; calling a function ; basic/void function ; value-returning function ; required main function 
 Ada ; foo «(parameters)» ; procedure foo «(parameters)» is begin statements end foo ; function foo «(parameters)» return type is begin statements end foo ; n/a 
 ALGOL 68 ;foo«(parameters)», ;proc foo = «(parameters)» void: ( instructions ), ;proc foo = «(parameters)» rettype: ( instructions ..., retvalue ), ; n/a 
 APL ; «parameters» foo parameters ; foo←{ statements } ; foo←{ statements } ; n/a 
 C (C99) ; foo(«parameters») ; void foo(«parameters») { instructions } ; type foo(«parameters») { instructions ... return value, } ; «global declarations»  int main(«int argc, char *argv[]») {  instructions  } 
 Objective-C ; foo(«parameters») ; void foo(«parameters») { instructions } ; type foo(«parameters») { instructions ... return value, } ; «global declarations»  int main(«int argc, char *argv[]») {  instructions  } 
 C++ (STL) ; foo(«parameters») ; void foo(«parameters») { instructions } ; type foo(«parameters») { instructions ... return value, } ; «global declarations»  int main(«int argc, char *argv[]») {  instructions  } 
 Java ; foo(«parameters») ; void foo(«parameters») { instructions } ; type foo(«parameters») { instructions ... return value, } ; public static void main(String[] args) { instructions } or public static void main(S... args) { instructions } 
 D ; foo(«parameters») ; void foo(«parameters») { instructions } ; type foo(«parameters») { instructions ... return value, } ; int main(«char[][] args») { instructions} or int main(«string[] args») { instructions} or void main(«char[][] args») { instructions} or void main(«string[] args») { instructions} 
 C# ; foo(«parameters») ;Same as above, alternatively, if only one statement: void foo(«parameters») => statement, ;Same as above, alternatively, if simple enough to be an expression: void foo(«parameters») => expression, ;static void Main(«string[] args») method_body  May instead return int.  (starting with C# 7.1:) May return Task or Task, and if so, may be async. 
 JavaScript ; foo(«parameters») ; function foo(«parameters») { instructions } or var foo = function («parameters») {instructions } or var foo = new Function («"parameter", ... ,"last parameter"» "instructions"), ; function foo(«parameters») { instructions ... return value, } ; n/a 
 Go ; foo(«parameters») ; func foo(«parameters») { instructions } ; func foo(«parameters») type { instructions ... return value } ; func main() { instructions } 
 Swift ; foo(«parameters») ; func foo(«parameters») { instructions } ; func foo(«parameters») -> type { instructions ... return value } ; n/a 
 Common Lisp ; (foo «parameters») ; (defun foo («parameters»)instructions) or (setf (symbol-function 'symbol)function) ; (defun foo («parameters»)...value) ; rowspan=3 n/a 
 Scheme ; (foo «parameters») ; (define (foo parameters) instructions) or  (define foo (lambda (parameters) instructions)) ; (define (foo parameters) instructions... return_value) or  (define foo (lambda (parameters) instructions... return_value)) 
 ISLISP ; (foo «parameters») ; (defun foo («parameters»)instructions) ; (defun foo («parameters»)...value) 
 Pascal ; foo«(parameters)» ; procedure foo«(parameters)», «forward,» «labellabel declarations» «constconstant declarations» «typetype declarations» «varvariable declarations» «local function declarations»begininstructionsend, ; function foo«(parameters)»: type, «forward,» «labellabel declarations» «constconstant declarations» «typetype declarations» «varvariable declarations» «local function declarations»begin instructions,  foo := valueend, ; program name, «labellabel declarations» «constconstant declarations» «typetype declarations» «varvariable declarations» «function declarations»begininstructions end.  
 Visual Basic ; Foo(«parameters») ; Sub Foo«(parameters)» instructions  End Sub ; Function Foo«(parameters)»« As type»instructions Foo = valueEnd Function ; Sub Main()instructionsEnd Sub 
 Visual Basic .NET ; Foo(«parameters») ; Sub Foo«(parameters)» instructions  End Sub ; Same as above, alternatively: Function Foo«(parameters)»« As type»instructionsReturn valueEnd Function    The As clause is not required if Option Strict is off. A type character may be used instead of the As clause.  If control exits the function without a return value having been explicitly specified, the function returns the default value for the return type. ; Sub Main(««ByVal »args() As String»)  instructions  End Subor  Function Main(««ByVal »args() As String») As Integer instructionsEnd Function 
 Xojo ; Foo(«parameters») ; Sub Foo«(parameters)» instructions  End Sub ; Same as above, alternatively: Function Foo«(parameters)»« As type»instructionsReturn valueEnd Function    The As clause is not required if Option Strict is off. A type character may be used instead of the As clause.  If control exits the function without a return value having been explicitly specified, the function returns the default value for the return type. ; Sub Main(««ByVal »args() As String»)  instructions  End Subor  Function Main(««ByVal »args() As String») As Integer instructionsEnd Function 
 Python ; foo(«parameters») ; def foo(«parameters»):  Tab instructions  ; def foo(«parameters»):  Tab instructions  Tab return value ; n/a 
 S-Lang ; foo(«parameters» «,qualifiers») ; define foo («parameters») { instructions } ; define foo («parameters») { instructions ... return value, } ; public define slsh_main () { instructions } 
 Fortran ; foo («arguments»)  CALL sub_foo («arguments») ; SUBROUTINE sub_foo («arguments»)  instructions  END SUBROUTINE ; type FUNCTION foo («arguments»)  instructions  ...  foo = value  END FUNCTION ; PROGRAM main  instructions  END PROGRAM 
 Forth ; «parameters» FOO ; : FOO  « stack effect comment: ( before -- ) »   instructions  , ; : FOO  « stack effect comment: ( before -- after ) »   instructions  , ; n/a 
 PHP ; foo(«parameters») ; function foo(«parameters») { instructions } ; function foo(«parameters») { instructions ... return value, } ; rowspan=4 n/a 
 Perl ; foo(«parameters») or  &foo«(parameters)» ; sub foo { «my (parameters) = @_,» instructions } ; sub foo { «my (parameters) = @_,» instructions... «return» value, } 
 Raku ; foo(«parameters») or  &foo«(parameters)» ; «multi »sub foo(parameters) { instructions } ; «our «type» »«multi »sub foo(parameters) { instructions... «return» value, } 
 Ruby ; foo«(parameters)» ; def foo«(parameters)» instructions  end ; def foo«(parameters)» instructions  «return» value  end 
 Rust ; foo(«parameters») ; fn foo(«parameters») { instructions } ; fn foo(«parameters») -> type { instructions } ; fn main() { instructions } 
 Scala ; foo«(parameters)» ; def foo«(parameters)»«: Unit =» { instructions } ; def foo«(parameters)»«: type» = { instructions ... «return» value } ; def main(args: Array[String]) { instructions } 
 Windows PowerShell ; foo «parameters» ; function foo  { instructions },orfunction foo { «param(parameters)» instructions } ; function foo «(parameters)»  { instructions  … return value }, orfunction foo { «param(parameters)» instructions … return value } ; rowspan=4 n/a 
Bash shell ;foo «parameters» ; function foo { 4instructions } or foo () { 4instructions  } ; function foo { 4instructions 4return «exit_code» } or foo () { 4instructions 4return «exit_code»  } 
Bash shell ;foo «parameters» ;  parameters $n ($1, $2, $3, ...) $@ (all parameters) $# (the number of parameters) $0 (this function name) ;  parameters $n ($1, $2, $3, ...) $@ (all parameters) $# (the number of parameters) $0 (this function name) 
 OCaml ; foo parameters ; let «rec» foo parameters = instructions ; let «rec» foo parameters = instructions... return_value 
 F# ; foo parameters ; let «rec» foo parameters = instructions ; let «rec» foo parameters = instructions... return_value ; [] let main args = instructions 
 Standard ML ; foo parameters ; fun foo parameters = ( instructions ) ; fun foo parameters = ( instructions... return_value ) ;  
 Haskell ; foo parameters ; foo parameters = doTab instructions ; foo parameters = return_value  or  foo parameters = doTab instructionsTab return value ; «main :: IO ()»  main = do instructions 
 Eiffel ; foo («parameters») ; foo («parameters»)require preconditions do instructions ensure postconditions end ; foo («parameters»): typerequire preconditions do instructionsResult := value ensure postconditions end ;  
 CoffeeScript ; foo() ; foo = -> ; foo = -> value ; rowspan=2 n/a 
 CoffeeScript ; foo parameters ; foo = () -> ; foo = ( parameters ) -> value 
 COBOL ; CALL "foo" «USING parameters»  «exception-handling»  «END-CALL» ; «IDENTIFICATION DIVISION.» PROGRAM-ID. foo. «other divisions...» PROCEDURE DIVISION «USING parameters».  instructions.  ; «IDENTIFICATION DIVISION.» PROGRAM-ID/FUNCTION-ID. foo. «other divisions...» DATA DIVISION. «other sections...» LINKAGE SECTION. «parameter definitions...» variable-to-return definition «other sections...» PROCEDURE DIVISION «USING parameters» RETURNING variable-to-return.  instructions. ; rowspan=2 n/a 
 COBOL ;«FUNCTION» foo«(«parameters»)» ; n/a ; «IDENTIFICATION DIVISION.» PROGRAM-ID/FUNCTION-ID. foo. «other divisions...» DATA DIVISION. «other sections...» LINKAGE SECTION. «parameter definitions...» variable-to-return definition «other sections...» PROCEDURE DIVISION «USING parameters» RETURNING variable-to-return.  instructions. 
