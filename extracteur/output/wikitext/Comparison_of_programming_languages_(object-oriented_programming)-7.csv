 ; unary ; binary ; function call 
 ABAP Objects ; colspan=3 n/a 
 C++ (STL) ; type operator symbol () { instructions } ; type operator symbol (type operand2) { instructions } ; type operator () («parameters») { instructions } 
 C# ; static type operator symbol(type operand) { instructions } ; static type operator symbol(type operand1, type operand2) { instructions } ; n/a 
 D ; type opUnary(string s)() if (s == "symbol") { instructions } ; type opBinary(string s)(type operand2) if (s == "symbol") { instructions }  type opBinaryRight(string s)(type operand1) if (s == "symbol") switch (s) { instructions } ; type opCall(«parameters») { instructions } 
 Java ; rowspan=2 colspan=3 n/a 
 Objective-C 
 Swift ; func symbol(operand1 : type) -> returntype { instructions } (outside class) ; func symbol(operand1 : type1, operand2 : type2) -> returntype { instructions } (outside class) ;  
 EiffelAlthough Eiffel does not support overloading of operators, it can define operators ; op_name alias "symbol": TYPE do instructions end ; op_name alias "symbol" (operand: TYPE1): TYPE2 do instructions end ;  
 Python ; def __opname__(self):  Tab instructions Tab return value ; def __opname__(self, operand2):  Tab instructions Tab return value ; def __call__(self«, paramters»):  Tab instructions Tab return value 
 Visual Basic .NET ; Shared Operator symbol(operand As type) As type instructions  End Operator ; Shared Operator symbol(operand1 As type, operand2 As type) As type instructions  End Operator ; n/a 
 Xojo ; Function Operator_name(operand As type) As type instructions  End Function ; colspan=2 n/a 
 PHP ;PHP does not support operator overloading natively, but support can be added using the "operator" PECL package. ;PHP does not support operator overloading natively, but support can be added using the "operator" PECL package. ; function __invoke(«parameters») { instructions } (PHP 5.3+) 
 Perl ; use overload "symbol" => sub { my ($self) = @_, instructions }, ; use overload "symbol" => sub { my ($self, $operand2, $operands_reversed) = @_, instructions }, ;  
 Raku ; «our «type »»«multi »method prefix:<symbol> («$operand: ») { instructions ... return value, } or «our «type »»«multi »method postfix:<symbol> («$operand: ») { instructions ... return value, } or «our «type »»«multi »method circumfix:<symbol1 symbol2> («$operand: ») { instructions ... return value, } ; «our «type »»«multi »method infix:<symbol> («$operand1: » type operand2) { instructions ... return value, } ; «our «type »»«multi »method postcircumfix:<( )> («$self: » «parameters») { instructions } 
 Ruby ; def symbol  instructions  expression resulting in return value  end ; def symbol(operand2)  instructions  expression resulting in return value  end ; n/a 
 Windows PowerShell ; rowspan=2 colspan=3 n/a 
 OCaml 
 F# ; static member (symbol) operand = expression ; static member (symbol) (operand1, operand2) = expression ; n/a 
 COBOL ; colspan=3 n/a 
 ISLISP ; colspan=3 n/a 
